<?xml version='1.0' encoding='utf-8'?>
<?xml-stylesheet type='text/xsl' href='style/stylecn.xsl'?>

<docs version="2.0">
  <cat value="核心">
    <subcat value="lhgcore 核心函数">
      <function name="lhgcore" return="lhgcore">
        <desc>这个函数接收一个包含 CSS 选择器的字符串，然后用这个字符串去匹配一组元素。</desc>
        <longdesc>lhgcore 的核心功能都是通过这个函数实现的。 lhgcore中的一切都基于这个函数，或者说都是在以某种方式使用这个函数。这个函数最基本的用法就是向它传递一个表达式（通常由 CSS 选择器组成），然后根据这个表达式来查找所有匹配的元素。

默认情况下, 如果没有指定context参数，J()将在当前的 HTML 文档中查找 DOM 元素；如果指定了 context 参数，context 为指定的页面的document对象，那就会在这个 context 中查找。

参考 Selectors 获取更多用于 expression 参数的 CSS 语法的信息。</longdesc>
        <params name="expression" type="String">
          <desc>用来查找的字符串</desc>
        </params>
        <params name="context" type="Document" optional="true">
          <desc>作为待查找的指定的文档对象。</desc>
        </params>
        <example>
          <desc>找到所有 p 元素，并且这些元素都必须是 div 元素的子元素。</desc>
          <html>&lt;p&gt;one&lt;/p&gt; &lt;div&gt;&lt;p&gt;two&lt;/p&gt;&lt;/div&gt; &lt;p&gt;three&lt;/p&gt;</html>
          <code>J("div &gt; p");</code>
          <result>[ &lt;p&gt;two&lt;/p&gt; ]</result>
        </example>
        <example>
          <desc>在指定的页面文档中查找所有的单选按钮(即: type 值为 radio 的 input 元素)。</desc>
          <code>J("input[type=radio]", window.frames['test'].contentWindow.document);</code>
        </example>
      </function>
      <function name="lhgcore" return="lhgcore">
        <desc>根据提供的原始 HTML 标记字符串，动态创建由 lhgcore 对象包装的 DOM 元素。</desc>
        <longdesc>你可以传递一个手写的 HTML 字符串，或者由某些模板引擎或插件创建的字符串，也可以是通过 AJAX 加载过来的字符串。但是在你创建 input 元素的时会有限制，可以参考第二个示例。当然这个字符串可以包含斜杠 (比如一个图像地址)，还有反斜杠。当你创建单个元素时，请使用闭合标签或 XHTML 格式。例如，创建一个 span ，可以用 <![CDATA[J("&lt;span/&gt;") 或 J("&lt;span&gt;&lt;/span&gt;") ，但不推荐 J("&lt;span&gt;")。]]>在lhgcore 中，这个语法等同于J(document.createElement("span")) 。</longdesc>
        <params name="html" type="String">
          <desc>用于动态创建DOM元素的HTML标记字符串</desc>
        </params>
        <params name="ownerDocument" type="Document" optional="true">
          <desc>创建DOM元素所在的文档</desc>
        </params>
        <example>
          <desc>动态创建一个 div 元素（以及其中的所有内容），并将它追加到 body 元素中。在这个函数的内部，是通过临时创建一个元素，并将这个元素的 innerHTML 属性设置为给定的标记字符串，来实现标记到 DOM 元素转换的。所以，这个函数既有灵活性，也有局限性。</desc>
          <code>J("&lt;div&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;").appendTo("body");</code>
        </example>
        <example>
          <desc>创建一个 &lt;input&gt; 元素必须同时设定 type 属性。因为微软规定 &lt;input&gt; 元素的 type 只能写一次。</desc>
          <code>// 在 IE 中无效:
J("&lt;input&gt;").attr("type", "checkbox");
// 在 IE 中有效:
J("&lt;input type='checkbox'&gt;");</code>
        </example>
      </function>
      <function name="lhgcore" return="lhgcore">
        <desc>将一个或多个DOM元素转化为lhgcore对象。</desc>
        <longdesc>这个函数也可以接收Window对象（虽然它们不是DOM元素）作为有效的参数。</longdesc>
        <params name="elements" type="Element, Array&lt;Element&gt;">
          <desc>用于封装成lhgcore对象的DOM元素</desc>
        </params>
        <example>
          <desc>设置页面背景色。</desc>
          <code>J(document.body).css( "background", "black" );</code>
        </example>
        <example>
          <desc>设置页面中所有div的innerHTML为test。</desc>
          <code>J(document.getElementsByTagName('div')).html( 'test' )</code>
        </example>
      </function>
      <function name="lhgcore" return="lhgcore">
        <desc>J(document).ready()的简写。</desc>
        <longdesc>允许你绑定一个在DOM文档载入完成后执行的函数。这个函数的作用如同J(document).ready()一样，只不过用这个函数时，需要把页面中所有需要在 DOM 加载完成时执行的$()操作符都包装到其中来。从技术上来说，这个函数是可链接的－－但真正以这种方式链接的情况并不多。

你可以在一个页面中使用任意多个J(document).ready事件。参考 ready(Function) 获取更多 ready 事件的信息。</longdesc>
        <params name="callback" type="Function">
          <desc>当DOM加载完成后要执行的函数</desc>
        </params>
        <example>
          <desc>当DOM加载完成后，执行其中的函数。</desc>
          <code>J(function(){
  // 文档就绪
});</code>
        </example>
      </function>
    </subcat>
    <subcat value="lhgcore 对象访问">
      <function name="each" return="lhgcore">
        <desc>以每一个匹配的元素作为上下文来执行一个函数。</desc>
        <longdesc>意味着，每次执行传递进来的函数时，函数中的this关键字都指向一个不同的DOM元素（每次都是一个不同的匹配元素）。而且，在每次执行函数时，都会给函数传递一个表示作为执行环境的元素在匹配的元素集合中所处位置的数字值作为参数（从零开始的整形）。 返回 'false' 将停止循环 (就像在普通的循环中使用 'break')。返回 'true' 跳至下一个循环(就像在普通的循环中使用'continue')。</longdesc>
        <params name="callback" type="Function">
          <desc>对于每个匹配的元素所要执行的函数</desc>
        </params>
        <example>
          <desc>迭代两个图像，并设置它们的 src 属性。注意:此处 this 指代的是 DOM 对象而非 lhgcore 对象。</desc>
          <html>&lt;img/&gt;&lt;img/&gt;</html>
          <code>J("img").each(function(i){
   this.src = "test" + i + ".jpg";
 });</code>
          <result>[ &lt;img src="test0.jpg" /&gt;, &lt;img src="test1.jpg" /&gt; ]</result>
        </example>
      </function>
    </subcat>
    <subcat value="插件机制">
      <function name="lhgcore.fn.extend" return="lhgcore">
        <desc>扩展 lhgcore 元素集来提供新的方法（通常用来制作插件）。</desc>
        <params name="object" type="Object">
          <desc>用来扩充 lhgcore 对象。</desc>
        </params>
        <example>
          <desc>增加两个插件方法。</desc>
          <code>J.fn.extend({
  check: function() {
    return this.each(function() { this.checked = true; });
  },
  uncheck: function() {
    return this.each(function() { this.checked = false; });
  }
});</code>
          <result>J("input[type=checkbox]").check();
J("input[type=radio]").uncheck();</result>
        </example>
      </function>
      <function name="lhgcore.extend" return="lhgcore">
        <desc>扩展lhgcore对象本身。</desc>
        <longdesc>用来在lhgcore命名空间上增加新函数。 </longdesc>
        <params name="object" type="Object">
          <desc>用以扩展 lhgcore 对象</desc>
        </params>
        <example>
          <desc>在lhgcore命名空间上增加两个函数。</desc>
          <code>J.extend({
  min: function(a, b) { return a &lt; b ? a : b; },
  max: function(a, b) { return a &gt; b ? a : b; }
});</code>
          <result>J.min(2,3); // =&gt; 2
J.max(4,5); // =&gt; 5</result>
        </example>
      </function>
    </subcat>
  </cat>
  <cat value="选择器">
    <subcat value="基本">
      <selector name="id" return="Array&lt;Element>">
        <sample>#id</sample>
        <desc>根据给定的ID匹配一个元素。</desc>
        <params name="id" type="String">
          <desc>用于搜索的，通过元素的 id 属性中给定的值</desc>
        </params>
        <example>
          <desc>查找 ID 为"myDiv"的元素。</desc>
          <html>&lt;div id="notMe"&gt;&lt;p&gt;id="notMe"&lt;/p&gt;&lt;/div&gt;
&lt;div id="myDiv"&gt;id="myDiv"&lt;/div&gt;</html>
          <code>J("#myDiv");</code>
          <result>[ &lt;div id="myDiv"&gt;id="myDiv"&lt;/div&gt; ]</result>
        </example>
      </selector>
      <selector name="element" return="Array&lt;Element(s)>">
        <sample>element</sample>
        <desc>根据给定的元素名匹配所有元素</desc>
        <params name="element" type="String">
          <desc>一个用于搜索的元素。指向 DOM 节点的标签名。</desc>
        </params>
        <example>
          <desc>查找一个 DIV 元素。</desc>
          <html>&lt;div&gt;DIV1&lt;/div&gt;
&lt;div&gt;DIV2&lt;/div&gt;
&lt;span&gt;SPAN&lt;/span&gt;</html>
          <code>J("div");</code>
          <result>[ &lt;div&gt;DIV1&lt;/div&gt;, &lt;div&gt;DIV2&lt;/div&gt; ]</result>
        </example>
      </selector>
      <selector name="class" return="Array&lt;Element(s)>">
        <sample>.class</sample>
        <desc>根据给定的类匹配元素。</desc>
        <params name="class" type="String">
          <desc>一个用以搜索的类。一个元素可以有多个类，只要有一个符合就能被匹配到。</desc>
        </params>
        <example>
          <desc>查找所有类是 "myClass" 的元素.</desc>
          <html>&lt;div class="notMe"&gt;div class="notMe"&lt;/div&gt;
&lt;div class="myClass"&gt;div class="myClass"&lt;/div&gt;
&lt;span class="myClass"&gt;span class="myClass"&lt;/span&gt;</html>
          <code>J(".myClass");</code>
          <result>[ &lt;div class="myClass"&gt;div class="myClass"&lt;/div&gt;, &lt;span class="myClass"&gt;span class="myClass"&lt;/span&gt; ]</result>
        </example>
      </selector>
      <selector name="all" return="Array&lt;Element(s)>">
        <sample>*</sample>
        <desc>匹配所有元素</desc>
        <longdesc>多用于结合上下文来搜索。</longdesc>
        <example>
          <desc>找到每一个元素</desc>
          <html>&lt;div&gt;DIV&lt;/div&gt;
&lt;span&gt;SPAN&lt;/span&gt;
&lt;p&gt;P&lt;/p&gt;</html>
          <code>J("*")</code>
          <result>[ &lt;div&gt;DIV&lt;/div&gt;, &lt;span&gt;SPAN&lt;/span&gt;, &lt;p&gt;P&lt;/p&gt; ]</result>
        </example>
      </selector>
      <selector name="multiple" return="Array&lt;Element(s)>">
        <sample>selector1,selector2,selectorN</sample>
        <desc>将每一个选择器匹配到的元素合并后一起返回。并且自动去掉重复的元素。</desc>
        <longdesc>你可以指定任意多个选择器，并将匹配到的元素合并到一个结果内。</longdesc>
        <params name="selector1" type="Selector">
          <desc>一个有效的选择器</desc>
        </params>
        <params name="selector2" type="Selector">
          <desc>另一个有效的选择器</desc>
        </params>
        <params name="selectorN" type="Selector" optional="true">
          <desc>任意多个有效选择器</desc>
        </params>
        <example>
          <desc>找到匹配任意一个类的元素。</desc>
          <html>&lt;div&gt;div&lt;/div&gt;
&lt;p class="myClass"&gt;p class="myClass"&lt;/p&gt;
&lt;span&gt;span&lt;/span&gt;
&lt;p class="notMyClass"&gt;p class="notMyClass"&lt;/p&gt;</html>
          <code>J("div,span,p.myClass")</code>
          <result>[ &lt;div&gt;div&lt;/div&gt;, &lt;p class="myClass"&gt;p class="myClass"&lt;/p&gt;, &lt;span&gt;span&lt;/span&gt; ]</result>
        </example>
      </selector>
    </subcat>
    <subcat value="层级">
      <selector name="descendant" return="Array&lt;Element(s)>">
        <sample>ancestor descendant</sample>
        <desc>在给定的祖先元素下匹配所有的后代元素</desc>
        <params name="ancestor" type="Selector">
          <desc>任何有效选择器</desc>
        </params>
        <params name="descendant" type="Selector">
          <desc>用以匹配元素的选择器，并且它是第一个选择器的后代元素</desc>
        </params>
        <example>
          <desc>找到表单中所有的 input 元素</desc>
          <html>&lt;form&gt;
  &lt;label&gt;Name:&lt;/label&gt;
  &lt;input name="name" /&gt;
  &lt;fieldset&gt;
      &lt;label&gt;Newsletter:&lt;/label&gt;
      &lt;input name="newsletter" /&gt;
 &lt;/fieldset&gt;
&lt;/form&gt;
&lt;input name="none" /&gt;</html>
          <code>J("form input")</code>
          <result>[ &lt;input name="name" /&gt;, &lt;input name="newsletter" /&gt; ]</result>
        </example>
      </selector>
      <selector name="child" return="Array&lt;Element(s)>">
        <sample>parent &gt; child</sample>
        <desc>在给定的父元素下匹配所有的子元素</desc>
        <params name="parent" type="Selector">
          <desc>任何有效选择器</desc>
        </params>
        <params name="child" type="Selector">
          <desc>用以匹配元素的选择器，并且它是第一个选择器的子元素</desc>
        </params>
        <example>
          <desc>匹配表单中所有的子级input元素。</desc>
          <html>&lt;form&gt;
  &lt;label&gt;Name:&lt;/label&gt;
  &lt;input name="name" /&gt;
  &lt;fieldset&gt;
      &lt;label&gt;Newsletter:&lt;/label&gt;
      &lt;input name="newsletter" /&gt;
 &lt;/fieldset&gt;
&lt;/form&gt;
&lt;input name="none" /&gt;</html>
          <code>J("form &gt; input")</code>
          <result>[ &lt;input name="name" /&gt; ]</result>
        </example>
      </selector>
    </subcat>
    <subcat value="属性">
      <selector name="attributeHas" return="Array&lt;Element(s)>">
        <sample>[attribute]</sample>
        <desc>匹配包含给定属性的元素。注意，属性名前不要加@符号。</desc>
        <params name="attribute" type="String">
          <desc>属性名</desc>
        </params>
        <example>
          <desc>查找所有含有 id 属性的 div 元素</desc>
          <html>&lt;div&gt;
  &lt;p&gt;Hello!&lt;/p&gt;
&lt;/div&gt;
&lt;div id="test2"&gt;&lt;/div&gt;</html>
          <code>J("div[id]")</code>
          <result>[ &lt;div id="test2"&gt;&lt;/div&gt; ]</result>
        </example>
      </selector>
      <selector name="attributeEquals" return="Array&lt;Element(s)>">
        <sample>[attribute=value]</sample>
        <desc>匹配给定的属性是某个特定值的元素</desc>
        <params name="attribute" type="String">
          <desc>属性名</desc>
        </params>
        <params name="value" type="String" optional="true">
          <desc>属性值。引号在大多数情况下是可选的。但在遇到诸如属性值包含"]"时，用以避免冲突。</desc>
        </params>
        <example>
          <desc>查找所有 name 属性是 newsletter 的 input 元素</desc>
          <html>&lt;input type="checkbox" name="newsletter" value="Hot Fuzz" /&gt;
&lt;input type="checkbox" name="newsletter" value="Cold Fusion" /&gt;
&lt;input type="checkbox" name="accept" value="Evil Plans" /&gt;</html>
          <code>J("input[name='newsletter']").attr("checked", true);</code>
          <result>[ &lt;input type="checkbox" name="newsletter" value="Hot Fuzz" checked="true" /&gt;, &lt;input type="checkbox" name="newsletter" value="Cold Fusion" checked="true" /&gt; ]</result>
        </example>
      </selector>
      <selector name="attributeStartsWith" return="Array&lt;Element(s)>">
        <sample>[attribute^=value]</sample>
        <desc>匹配给定的属性是以某些值开始的元素</desc>
        <params name="attribute" type="String">
          <desc>属性名</desc>
        </params>
        <params name="value" type="String" optional="true">
          <desc>属性值。引号在大多数情况下是可选的。但在遇到诸如属性值包含"]"时，用以避免冲突。</desc>
        </params>
        <example>
          <desc>查找所有 name 以 'news' 开始的 input 元素</desc>
          <html>&lt;input name="newsletter" /&gt;
&lt;input name="milkman" /&gt;
&lt;input name="newsboy" /&gt;</html>
          <code>J("input[name^='news']")</code>
          <result>[ &lt;input name="newsletter" /&gt;, &lt;input name="newsboy" /&gt; ]</result>
        </example>
      </selector>
      <selector name="attributeEndsWith" return="Array&lt;Element(s)>">
        <sample>[attribute$=value]</sample>
        <desc>匹配给定的属性是以某些值结尾的元素</desc>
        <params name="attribute" type="String">
          <desc>属性名</desc>
        </params>
        <params name="value" type="String" optional="true">
          <desc>属性值。引号在大多数情况下是可选的。但在遇到诸如属性值包含"]"时，用以避免冲突。</desc>
        </params>
        <example>
          <desc>查找所有 name 以 'letter' 结尾的 input 元素</desc>
          <html>&lt;input name="newsletter" /&gt;
&lt;input name="milkman" /&gt;
&lt;input name="jobletter" /&gt;</html>
          <code>J("input[name$='letter']")</code>
          <result>[ &lt;input name="newsletter" /&gt;, &lt;input name="jobletter" /&gt; ]</result>
        </example>
      </selector>
      <selector name="attributeContains" return="Array&lt;Element(s)>">
        <sample>[attribute%=value]</sample>
        <desc>匹配给定的属性是以包含某些值的元素</desc>
        <params name="attribute" type="String">
          <desc>属性名</desc>
        </params>
        <params name="value" type="String" optional="true">
          <desc>属性值。引号在大多数情况下是可选的。但在遇到诸如属性值包含"]"时，用以避免冲突。</desc>
        </params>
        <example>
          <desc>查找所有 name 包含 'man' 的 input 元素</desc>
          <html>&lt;input name="man-news" /&gt;
&lt;input name="milkman" /&gt;
&lt;input name="letterman2" /&gt;
&lt;input name="newmilk" /&gt;</html>
          <code>J("input[name%='man']")</code>
          <result>[ &lt;input name="man-news" /&gt;, &lt;input name="milkman" /&gt;, &lt;input name="letterman2" /&gt; ]</result>
        </example>
      </selector>
      <selector name="attributeMultiple" return="Array&lt;Element(s)>">
        <sample>[selector1][selector2][selectorN]</sample>
        <desc>复合属性选择器，需要同时满足多个条件时使用。</desc>
        <params name="selector1" type="Selector">
          <desc>属性选择器</desc>
        </params>
        <params name="selector2" type="Selector">
          <desc>另一个属性选择器，用以进一步缩小范围</desc>
        </params>
        <params name="selectorN" type="Selector">
          <desc>任意多个属性选择器</desc>
        </params>
        <example>
          <desc>找到所有含有 id 属性，并且它的 name 属性是以 man 结尾的</desc>
          <html>&lt;input id="man-news" name="man-news" /&gt;
&lt;input name="milkman" /&gt;
&lt;input id="letterman" name="new-letterman" /&gt;
&lt;input name="newmilk" /&gt;</html>
          <code>J("input[id][name$='man']")</code>
          <result>[ &lt;input id="letterman" name="new-letterman" /&gt; ]</result>
        </example>
      </selector>
    </subcat>
  </cat>
  <cat value="属性">
    <subcat value="属性">
      <function name="attr" return="Object">
        <desc>取得第一个匹配元素的属性值。通过这个方法可以方便地从第一个匹配元素中获取一个属性的值。如果元素没有相应属性，则返回 undefined 。</desc>
        <params name="name" type="String">
          <desc>属性名称</desc>
        </params>
        <example>
          <desc>返回文档中第一个图像的src属性值。</desc>
          <html>&lt;img src="test.jpg"/&gt;</html>
          <code>J("img").attr("src");</code>
          <result>test.jpg</result>
        </example>
      </function>
      <function name="attr" return="lhgcore">
        <desc>将一个“名/值”形式的对象设置为所有匹配元素的属性。</desc>
        <longdesc>这是一种在所有匹配元素中批量设置很多属性的最佳方式。 注意，如果你要设置对象的class属性，你必须使用'className' 作为属性名。或者你可以直接使用.addClass( class ) 和 .removeClass( class ).</longdesc>
        <params name="properties" type="Map">
          <desc>作为属性的“名/值对”对象</desc>
        </params>
        <example>
          <desc>为所有图像设置src和alt属性。</desc>
          <html>&lt;img/&gt;</html>
          <code>J("img").attr({ src: "test.jpg", alt: "Test Image" });</code>
          <result>[ &lt;img src= "test.jpg"  alt:="Test Image" /&gt; ]</result>
        </example>
      </function>
      <function name="attr" return="lhgcore">
        <desc>为所有匹配的元素设置一个属性值。</desc>
        <params name="key" type="String">
          <desc>属性名称</desc>
        </params>
        <params name="value" type="Object">
          <desc>属性值</desc>
        </params>
        <example>
          <desc>为所有图像设置src属性。</desc>
          <html>&lt;img/&gt; 
&lt;img/&gt;</html>
          <code>J("img").attr("src","test.jpg");</code>
          <result>[ &lt;img src= "test.jpg" /&gt; , &lt;img src= "test.jpg" /&gt; ]</result>
        </example>
      </function>
      <function name="attr" return="lhgcore">
        <desc>为所有匹配的元素设置一个计算的属性值。</desc>
        <longdesc>不提供值，而是提供一个函数，由这个函数计算的值作为属性值。</longdesc>
        <params name="key" type="String">
          <desc>属性名称</desc>
        </params>
        <params name="fn" type="Function">
          <desc>返回值的函数 范围:当前元素, 参数: 当前元素的索引值</desc>
        </params>
        <example>
          <desc>把src属性的值设置为title属性的值。</desc>
          <html>&lt;img src="test.jpg"/&gt;</html>
          <code>J("img").attr("title", function() { return this.src });</code>
          <result>&lt;img src="test.jpg" title="test.jpg" /&gt;</result>
        </example>
      </function>
      <function name="removeAttr" return="lhgcore">
        <desc>从每一个匹配的元素中删除一个属性</desc>
        <params name="name" type="String">
          <desc>要删除的属性名</desc>
        </params>
        <example>
          <desc>将文档中图像的src属性删除</desc>
          <html>&lt;img src="test.jpg"/&gt;</html>
          <code>J("img").removeAttr("src");</code>
          <result>[ &lt;img /&gt; ]</result>
        </example>
      </function>
    </subcat>
    <subcat value="CSS 类">
      <function name="addClass" return="lhgcore">
        <desc>为每个匹配的元素添加指定的类名。</desc>
        <params name="class" type="String">
          <desc>一个或多个要添加到元素中的CSS类名，请用空格分开</desc>
        </params>
        <example>
          <desc>为匹配的元素加上 'selected' 类</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;</html>
          <code>J("p").addClass("selected");</code>
          <result>[ &lt;p class="selected"&gt;Hello&lt;/p&gt; ]</result>
        </example>
        <example>
          <desc>为匹配的元素加上 selected highlight 类</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;</html>
          <code>J("p").addClass("selected highlight");</code>
          <result>[ &lt;p class="selected highlight"&gt;Hello&lt;/p&gt; ]</result>
        </example>
      </function>
      <function name="removeClass" return="lhgcore">
        <desc>从所有匹配的元素中删除全部类。</desc>
        <example>
          <desc>删除匹配元素的所有类</desc>
          <html>&lt;p class="selected first"&gt;Hello&lt;/p&gt;</html>
          <code>J("p").removeClass();</code>
          <result>[ &lt;p&gt;Hello&lt;/p&gt; ]</result>
        </example>
      </function>
      <function name="toggleClass" return="lhgcore">
        <desc>如果存在（不存在）就删除（添加）一个类。</desc>
        <params name="class" type="String">
          <desc>CSS类名</desc>
        </params>
        <example>
          <desc>为匹配的元素切换 'selected' 类</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p class="selected"&gt;Hello Again&lt;/p&gt;</html>
          <code>J("p").toggleClass("selected");</code>
          <result>[ &lt;p class="selected"&gt;Hello&lt;/p&gt;, &lt;p&gt;Hello Again&lt;/p&gt; ]</result>
        </example>
      </function>
      <function name="toggleClass" return="lhgcore">
        <desc>如果开关switch参数为true则加上对应的class，否则就删除。</desc>
        <params name="class" type="String">
          <desc>要切换的CSS类名</desc>
        </params>
        <params name="switch" type="Boolean">
          <desc>用于决定元素是否包含class的布尔值。</desc>
        </params>
        <example>
          <desc>每点击三下加上一次 'selected' 类</desc>
          <html>&lt;strong&gt;lhgcore 代码:&lt;/strong&gt;</html>
          <code>  var count = 0;
  J("p").click(function(){
      J(this).toggleClass("highlight", count++ % 3 == 0);
  });</code>
        </example>
      </function>
    </subcat>
    <subcat value="HTML代码">
      <function name="html" return="String">
        <desc>取得第一个匹配元素的html内容。这个函数不能用于XML文档。但可以用于XHTML文档。</desc>
      </function>
      <function name="html" return="lhgcore">
        <desc>设置每一个匹配元素的html内容。这个函数不能用于XML文档。但可以用于XHTML文档。</desc>
        <params name="val" type="String">
          <desc>用于设定HTML内容的值</desc>
        </params>
      </function>
    </subcat>
    <subcat value="文本">
      <function name="text" return="String">
        <desc>取得所有匹配元素的内容。</desc>
        <longdesc>结果是由所有匹配元素包含的文本内容组合起来的文本。这个方法对HTML和XML文档都有效。</longdesc>
      </function>
      <function name="text" return="lhgcore">
        <desc>设置所有匹配元素的文本内容</desc>
        <longdesc>与 html() 类似, 但将编码 HTML (将 "&lt;" 和 "&gt;" 替换成相应的HTML实体).</longdesc>
        <params name="val" type="String">
          <desc>用于设置元素内容的文本</desc>
        </params>
      </function>
    </subcat>
    <subcat value="值">
      <function name="val" return="String,Array">
        <desc>获得第一个匹配元素的当前值。</desc>
        <example>
          <desc>获取文本框中的值</desc>
          <html>&lt;input type="text" value="some text"/&gt;</html>
          <code>J("input").val();</code>
          <result>some text</result>
        </example>
      </function>
      <function name="val" return="lhgcore">
        <desc>设置每一个匹配元素的值。</desc>
        <params name="val" type="String">
          <desc>要设置的值。</desc>
        </params>
        <example>
          <desc>设定文本框的值</desc>
          <html>&lt;input type="text"/&gt;</html>
          <code>J("input").val("hello world!");</code>
        </example>
      </function>
      <function name="val" return="lhgcore">
        <desc>check,select,radio等都能使用为之赋值</desc>
        <params name="val" type="Array&lt;String&gt;">
          <desc>用于 check/select 的值</desc>
        </params>
        <example>
          <desc>设定一个select的值</desc>
          <html>&lt;select id="single"&gt;
  &lt;option&gt;Single&lt;/option&gt;
  &lt;option&gt;Single2&lt;/option&gt;
&lt;/select&gt;
</html>
          <code>J("#single").val("Single2");</code>
        </example>
      </function>
    </subcat>
  </cat>
  <cat value="文档处理">
    <subcat value="内部插入">
      <function name="append" return="lhgcore">
        <desc>向每个匹配的元素内部追加内容。</desc>
        <longdesc>这个操作与对指定的元素执行appendChild方法，将它们添加到文档中的情况类似。</longdesc>
        <params name="content" type="String, Element, lhgcore">
          <desc>要追加到目标中的内容</desc>
        </params>
        <example>
          <desc>向所有段落中追加一些HTML标记。</desc>
          <html>&lt;p&gt;I would like to say: &lt;/p&gt;</html>
          <code>J("p").append("&lt;b&gt;Hello&lt;/b&gt;");</code>
          <result>[ &lt;p&gt;I would like to say: &lt;b&gt;Hello&lt;/b&gt;&lt;/p&gt; ]</result>
        </example>
      </function>
      <function name="appendTo" return="lhgcore">
        <desc>把所有匹配的元素追加到另一个、指定的元素元素集合中。</desc>
        <longdesc>实际上，使用这个方法是颠倒了常规的J(A).append(B)的操作，即不是把B追加到A中，而是把A追加到B中。</longdesc>
        <params name="content" type="String">
          <desc>用于被追加的内容</desc>
        </params>
        <example>
          <desc>把所有段落追加到ID值为foo的元素中。</desc>
          <html>&lt;p&gt;I would like to say: &lt;/p&gt;&lt;div id="foo"&gt;&lt;/div&gt;</html>
          <code>J("p").appendTo("#foo");</code>
          <result>&lt;div id="foo"&gt;&lt;p&gt;I would like to say: &lt;/p&gt;&lt;/div&gt;</result>
        </example>
      </function>
      <function name="prepend" return="lhgcore">
        <desc>向每个匹配的元素内部前置内容。</desc>
        <longdesc>这是向所有匹配元素内部的开始处插入内容的最佳方式。</longdesc>
        <params name="content" type="String, Element, lhgcore">
          <desc>要插入到目标元素内部前端的内容</desc>
        </params>
        <example>
          <desc>向所有段落中前置一些HTML标记代码。</desc>
          <html>&lt;p&gt;I would like to say: &lt;/p&gt;</html>
          <code>J("p").prepend("&lt;b&gt;Hello&lt;/b&gt;");</code>
          <result>[ &lt;p&gt;&lt;b&gt;Hello&lt;/b&gt;I would like to say: &lt;/p&gt; ]</result>
        </example>
        <example>
          <desc>将一个DOM元素前置入所有段落</desc>
          <html>&lt;p&gt;I would like to say: &lt;/p&gt;
&lt;p&gt;I would like to say: &lt;/p&gt;
&lt;b class="foo"&gt;Hello&lt;/b&gt;
&lt;b class="foo"&gt;Good Bye&lt;/b&gt;</html>
          <code>J("p").prepend( J(".foo")[0] );</code>
          <result>&lt;p&gt;&lt;b class="foo"&gt;Hello&lt;/b&gt;I would like to say: &lt;/p&gt;
&lt;p&gt;&lt;b class="foo"&gt;Hello&lt;/b&gt;I would like to say: &lt;/p&gt;
&lt;b class="foo"&gt;Hello&lt;/b&gt;
&lt;b class="foo"&gt;Good Bye&lt;/b&gt;</result>
        </example>
        <example>
          <desc>向所有段落中前置一个lhgcore对象(类似于一个DOM元素数组)。</desc>
          <html>&lt;p&gt;I would like to say: &lt;/p&gt;&lt;b&gt;Hello&lt;/b&gt;</html>
          <code>J("p").prepend( J("b") );</code>
          <result>&lt;p&gt;&lt;b&gt;Hello&lt;/b&gt;I would like to say: &lt;/p&gt;</result>
        </example>
      </function>
      <function name="prependTo" return="lhgcore">
        <desc>把所有匹配的元素前置到另一个、指定的元素元素集合中。</desc>
        <longdesc>实际上，使用这个方法是颠倒了常规的J(A).prepend(B)的操作，即不是把B前置到A中，而是把A前置到B中。</longdesc>
        <params name="content" type="String">
          <desc>用于匹配元素的lhgcore表达式</desc>
        </params>
        <example>
          <desc>把所有段落追加到ID值为foo的元素中。</desc>
          <html>&lt;p&gt;I would like to say: &lt;/p&gt;&lt;div id="foo"&gt;&lt;/div&gt;</html>
          <code>J("p").prependTo("#foo");</code>
          <result>&lt;div id="foo"&gt;&lt;p&gt;I would like to say: &lt;/p&gt;&lt;/div&gt;</result>
        </example>
      </function>
    </subcat>
    <subcat value="外部插入">
      <function name="after" return="lhgcore">
        <desc>在每个匹配的元素之后插入内容。</desc>
        <params name="content" type="String, Element, lhgcore">
          <desc>插入到每个目标后的内容</desc>
        </params>
        <example>
          <desc>在所有段落之后插入一些HTML标记代码。</desc>
          <html>&lt;p&gt;I would like to say: &lt;/p&gt;</html>
          <code>J("p").after("&lt;b&gt;Hello&lt;/b&gt;");</code>
          <result>&lt;p&gt;I would like to say: &lt;/p&gt;&lt;b&gt;Hello&lt;/b&gt;</result>
        </example>
        <example>
          <desc>在所有段落之后插入一个DOM元素。</desc>
          <html>&lt;b id="foo"&gt;Hello&lt;/b&gt;&lt;p&gt;I would like to say: &lt;/p&gt;</html>
          <code>J("p").after( J("#foo")[0] );</code>
          <result>&lt;p&gt;I would like to say: &lt;/p&gt;&lt;b id="foo"&gt;Hello&lt;/b&gt;</result>
        </example>
        <example>
          <desc>在所有段落中后插入一个lhgcore对象(类似于一个DOM元素数组)。</desc>
          <html>&lt;b&gt;Hello&lt;/b&gt;&lt;p&gt;I would like to say: &lt;/p&gt;</html>
          <code>J("p").after( J("b") );</code>
          <result>&lt;p&gt;I would like to say: &lt;/p&gt;&lt;b&gt;Hello&lt;/b&gt;</result>
        </example>
      </function>
      <function name="before" return="lhgcore">
        <desc>在每个匹配的元素之前插入内容。</desc>
        <params name="content" type="String, Element, lhgcore">
          <desc>插入到每个目标前的内容</desc>
        </params>
        <example>
          <desc>在所有段落之前插入一些HTML标记代码。</desc>
          <html>&lt;p&gt;I would like to say: &lt;/p&gt;</html>
          <code>J("p").before("&lt;b&gt;Hello&lt;/b&gt;");</code>
          <result>[ &lt;b&gt;Hello&lt;/b&gt;&lt;p&gt;I would like to say: &lt;/p&gt; ]</result>
        </example>
        <example>
          <desc>在所有段落之前插入一个元素。</desc>
          <html>&lt;p&gt;I would like to say: &lt;/p&gt;&lt;b id="foo"&gt;Hello&lt;/b&gt;</html>
          <code>J("p").before( J("#foo")[0] );</code>
          <result>&lt;b id="foo"&gt;Hello&lt;/b&gt;&lt;p&gt;I would like to say: &lt;/p&gt;</result>
        </example>
        <example>
          <desc>在所有段落中前插入一个lhgcore对象(类似于一个DOM元素数组)。</desc>
          <html>&lt;p&gt;I would like to say: &lt;/p&gt;&lt;b&gt;Hello&lt;/b&gt;</html>
          <code>J("p").before( J("b") );</code>
          <result>&lt;b&gt;Hello&lt;/b&gt;&lt;p&gt;I would like to say: &lt;/p&gt;</result>
        </example>
      </function>
      <function name="insertAfter" return="lhgcore">
        <desc>把所有匹配的元素插入到另一个、指定的元素元素集合的后面。</desc>
        <longdesc>实际上，使用这个方法是颠倒了常规的J(A).after(B)的操作，即不是把B插入到A后面，而是把A插入到B后面。</longdesc>
        <params name="content" type="String">
          <desc>用于匹配元素的lhgcore表达式</desc>
        </params>
        <example>
          <desc>把所有段落插入到一个元素之后。与 $("#foo").after("p")相同</desc>
          <html>&lt;p&gt;I would like to say: &lt;/p&gt;&lt;div id="foo"&gt;Hello&lt;/div&gt;</html>
          <code>J("p").insertAfter("#foo");</code>
          <result>&lt;div id="foo"&gt;Hello&lt;/div&gt;&lt;p&gt;I would like to say: &lt;/p&gt;</result>
        </example>
      </function>
      <function name="insertBefore" return="lhgcore">
        <desc>把所有匹配的元素插入到另一个、指定的元素元素集合的前面。</desc>
        <longdesc>实际上，使用这个方法是颠倒了常规的J(A).before(B)的操作，即不是把B插入到A前面，而是把A插入到B前面。</longdesc>
        <params name="content" type="String">
          <desc>用于匹配元素的lhgcore表达式</desc>
        </params>
        <example>
          <desc>把所有段落插入到一个元素之前。与 $("#foo").before("p")相同。</desc>
          <html>&lt;div id="foo"&gt;Hello&lt;/div&gt;&lt;p&gt;I would like to say: &lt;/p&gt;</html>
          <code>J("p").insertBefore("#foo");</code>
          <result>&lt;p&gt;I would like to say: &lt;/p&gt;&lt;div id="foo"&gt;Hello&lt;/div&gt;</result>
        </example>
      </function>
    </subcat>
    <subcat value="删除">
      <function name="remove" return="lhgcore">
        <desc>从DOM中删除所有匹配的元素。</desc>
        <example>
          <desc>从DOM中把所有段落删除</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt; how are &lt;p&gt;you?&lt;/p&gt;</html>
          <code>J("p").remove();</code>
          <result>how are</result>
        </example>
      </function>
    </subcat>
  </cat>
  <cat value="CSS">
    <subcat value="CSS">
      <function name="css" return="String">
        <desc>访问第一个匹配元素的样式属性。</desc>
        <params name="name" type="String">
          <desc>要访问的属性名称</desc>
        </params>
        <example>
          <desc>取得第一个段落的color样式属性的值。</desc>
          <code>J("p").css("color");</code>
        </example>
      </function>
      <function name="css" return="lhgcore">
        <desc>把一个“名/值对”对象设置为所有匹配元素的样式属性。</desc>
        <longdesc>这是一种在所有匹配的元素上设置大量样式属性的最佳方式。</longdesc>
        <params name="properties" type="Map">
          <desc>要设置为样式属性的名/值对</desc>
        </params>
        <example>
          <desc>将所有段落的字体颜色设为红色并且背景为蓝色。</desc>
          <code>J("p").css({ color: "#ff0011", background: "blue" });</code>
        </example>
      </function>
      <function name="css" return="lhgcore">
        <desc>在所有匹配的元素中，设置一个样式属性的值。</desc>
        <longdesc>数字将自动转化为像素值</longdesc>
        <params name="name" type="value">
          <desc>属性名</desc>
        </params>
        <params name="value" type="String, Number">
          <desc>属性值</desc>
        </params>
        <example>
          <desc>将所有段落字体设为红色</desc>
          <code>J("p").css("color","red");</code>
        </example>
      </function>
    </subcat>
  </cat>
  <cat value="事件">
    <subcat value="页面载入">
      <function name="ready" return="lhgcore">
        <desc>当DOM载入就绪可以查询及操纵时绑定一个要执行的函数。</desc>
        <longdesc>这是事件模块中最重要的一个函数，因为它可以极大地提高web应用程序的响应速度。

简单地说，这个方法纯粹是对向window.load事件注册事件的替代方法。通过使用这个方法，可以在DOM载入就绪能够读取并操纵时立即调用你所绑定的函数，而99.99%的JavaScript函数都需要在那一刻执行。

有一个参数－－对lhgcore函数的引用－－会传递到这个ready事件处理函数中。可以给这个参数任意起一个名字，并因此可以不再担心命名冲突而放心地使用$别名。

请确保在 &lt;body&gt; 元素的onload事件中没有注册函数，否则不会触发J(document).ready()事件。

可以在同一个页面中无限次地使用J(document).ready()事件。其中注册的函数会按照（代码中的）先后顺序依次执行。</longdesc>
        <params name="fn" type="Function">
          <desc>要在DOM就绪时执行的函数</desc>
        </params>
        <example>
          <desc>在DOM加载完成时运行的代码，可以这样写：</desc>
          <code>J(document).ready(function(){
  // 在这里写你的代码...
});</code>
        </example>
      </function>
    </subcat>
    <subcat value="事件处理">
      <function name="bind" return="lhgcore">
        <desc>为每一个匹配元素的特定事件（像click）绑定一个事件处理器函数。</desc>
        <longdesc>这个事件处理函数会接收到一个事件对象，可以通过它来阻止（浏览器）默认的行为。如果既想取消默认的行为，又想阻止事件起泡，这个事件处理函数必须返回false。多数情况下，可以把事件处理器函数定义为匿名函数（见示例一）。</longdesc>
        <params name="type" type="String">
          <desc>事件类型</desc>
        </params>
        <params name="fn" type="Function">
          <desc>绑定到每个匹配元素的事件上面的处理函数</desc>
        </params>
        <example>
          <desc>当每个段落被点击的时候，弹出其文本。</desc>
          <code>J("p").bind("click", function(){
  alert( $(this).text() );
});</code>
        </example>
        <example>
          <desc>通过返回false来取消默认的行为并阻止事件起泡。</desc>
          <code>$("form").bind("submit", function() { return false; })</code>
        </example>
        <example>
          <desc>通过使用 preventDefault() 方法只取消默认的行为。</desc>
          <code>J("form").bind("submit", function(event){
  event.preventDefault();
});</code>
        </example>
        <example>
          <desc>通过使用 stopPropagation() 方法只阻止一个事件起泡。</desc>
          <code>J("form").bind("submit", function(event){
  event.stopPropagation();
});</code>
        </example>
      </function>
      <function name="unbind" return="lhgcore">
        <desc>bind()的反向操作，从每一个匹配的元素中删除绑定的事件。</desc>
        <params name="type" type="String">
          <desc>事件类型</desc>
        </params>
        <params name="fn" type="Function">
          <desc>要从每个匹配元素的事件中反绑定的事件处理函数</desc>
        </params>
        <example>
          <desc>把所有段落的所有事件取消绑定</desc>
          <code>J("p").unbind()</code>
        </example>
        <example>
          <desc>将段落的click事件取消绑定</desc>
          <code>J("p").unbind( "click" )</code>
        </example>
      </function>
	</subcat>
    <subcat value="事件切换">
      <function name="hover" return="lhgcore">
        <desc>一个模仿悬停事件（鼠标移动到一个对象上面及移出这个对象）的方法。这是一个自定义的方法，它为频繁使用的任务提供了一种“保持在其中”的状态。</desc>
        <longdesc>当鼠标移动到一个匹配的元素上面时，会触发指定的第一个函数。当鼠标移出这个元素时，会触发指定的第二个函数。而且，会伴随着对鼠标是否仍然处在特定元素中的检测（例如，处在div中的图像），如果是，则会继续保持“悬停”状态，而不触发移出事件（修正了使用mouseout事件的一个常见错误）。</longdesc>
        <params name="over" type="Function">
          <desc>鼠标移到元素上要触发的函数</desc>
        </params>
        <params name="out" type="Function">
          <desc>鼠标移出元素要触发的函数</desc>
        </params>
        <example>
          <desc>鼠标悬停的表格加上特定的类</desc>
          <code>J("td").hover(
  function () {
    J(this).addClass("hover");
  },
  function () {
    J(this).removeClass("hover");
  }
);</code>
        </example>
      </function>
    </subcat>
    <subcat value="事件">
      <function name="blur" return="lhgcore">
        <desc>在每一个匹配元素的blur事件中绑定一个处理函数。</desc>
        <longdesc>blur事件会在元素失去焦点的时候触发，既可以是鼠标行为，也可以是按tab键离开的</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的blur事件中绑定的处理函数。</desc>
        </params>
        <example>
          <desc>任何段落失去焦点时弹出一个 "Hello World!"在每一个匹配元素的blur事件中绑定的处理函数。</desc>
          <code>J("p").blur( function () { alert("Hello World!"); } );</code>
        </example>
      </function>
      <function name="change" return="lhgcore">
        <desc>在每一个匹配元素的change事件中绑定一个处理函数。</desc>
        <longdesc>change事件会在元素失去焦点的时候触发，也会当其值在获得焦点后改变时触发。</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的change事件中绑定的处理函数。</desc>
        </params>
        <example>
          <desc>给所有的文本框增加输入验证</desc>
          <code>J("input[type='text']").change( function() {
  // 这里可以写些验证代码
});</code>
        </example>
      </function>
      <function name="click" return="lhgcore">
        <desc>在每一个匹配元素的click事件中绑定一个处理函数。</desc>
        <longdesc>点击事件会在你的指针设备的按钮在元素上单击时触发。单击的定义是在屏幕的同一点触发了mousedown和mouseup.几个事件触发的顺序是：mousedownmouseupclick</longdesc>
        <params name="fn" type="Function">
          <desc>绑定到click事件的函数</desc>
        </params>
        <example>
          <desc>将页面内所有段落点击后隐藏。</desc>
          <code>J("p").click( function () { $(this).hide(); });</code>
        </example>
      </function>
      <function name="dblclick" return="lhgcore">
        <desc>在每一个匹配元素的dblclick事件中绑定一个处理函数。</desc>
        <longdesc>的那个在某个元素上双击的时候就会触发dblclick事件</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的dblclick事件中绑定的处理函数。</desc>
        </params>
        <example>
          <desc>给页面上每个段落的双击事件绑上 "Hello World!" 警告框</desc>
          <code>J("p").dblclick( function () { alert("Hello World!"); });</code>
        </example>
      </function>
      <function name="error" return="lhgcore">
        <desc>在每一个匹配元素的error事件中绑定一个处理函数。</desc>
        <longdesc>对于error事件，没有一个公众的标准。在大多数浏览器中，当页面的JavaScript发生错误时，window对象会触发error事件;当图像的src属性无效时，比如文件不存在或者图像数据错误时，也会触发图像对象的error事件。

如果异常是由window对象抛出，事件处理函数将会被传入三个参数：

1. 描述事件的信息 ("varName is not defined", "missing operator in expression", 等等.),

2. 包含错误的文档的完整URL

3. 异常发生的行数 如果事件处理函数返回true，则表示事件已经被处理，浏览器将认为没有异常。

更多相关信息: 

&lt;a href="http://msdn2.microsoft.com/en-us/library/ms536930.aspx"&gt;msdn - onerror Event&lt;/a&gt;

&lt;a href="http://developer.mozilla.org/en/docs/DOM:window.onerror"&gt;Gecko DOM Reference - onerror Event&lt;/a&gt;

&lt;a href="http://developer.mozilla.org/en/docs/DOM:event"&gt;Gecko DOM Reference - Event object&lt;/a&gt;

&lt;a href="http://en.wikipedia.org/wiki/DOM_Events"&gt;Wikipedia: DOM Events&lt;/a&gt;</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的error事件中绑定的处理函数。</desc>
        </params>
        <example>
          <desc>隐藏JavaScript错误:</desc>
          <code>J(window).error(function(){
  return true;
});</code>
        </example>
        <example>
          <desc>给你IE的用户隐藏无效的图像:</desc>
          <code>J("img").error(function(){
  J(this).hide();
});</code>
        </example>
      </function>
      <function name="focus" return="lhgcore">
        <desc>在每一个匹配元素的focus事件中绑定一个处理函数。</desc>
        <longdesc>focus事件可以通过鼠标点击或者键盘上的TAB导航触发</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的focus事件中绑定的处理函数。</desc>
        </params>
        <example>
          <desc>使人无法使用文本框:</desc>
          <code>J("input[type=text]").focus(function(){
  this.blur();
});</code>
        </example>
      </function>
      <function name="keydown" return="lhgcore">
        <desc>在每一个匹配元素的keydown事件中绑定一个处理函数。</desc>
        <longdesc>keydown事件会在键盘按下时触发。</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的keydown事件中绑定的处理函数。</desc>
        </params>
        <example>
          <desc>在页面内对键盘按键做出回应，可以使用如下代码:</desc>
          <code>J(window).keydown(function(event){
  switch(event.keyCode) {
    // ...
    // 不同的按键可以做不同的事情
    // 不同的浏览器的keycode不同
    // 更多详细信息:     http://unixpapa.com/js/key.html
    // ...
  }
});</code>
        </example>
      </function>
      <function name="keypress" return="lhgcore">
        <desc>在每一个匹配元素的keypress事件中绑定一个处理函数。</desc>
        <longdesc>keypress事件会在敲击按键时触发。 敲击按键的定义为按下并抬起同一个按键。这几个事件发生的顺序是:keydown

keypress

keyup</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的keypress事件中绑定的处理函数。</desc>
        </params>
      </function>
      <function name="keyup" return="lhgcore">
        <desc>在每一个匹配元素的keyup事件中绑定一个处理函数。</desc>
        <longdesc>keyup 事件会在键盘按下时触发。</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的keyup事件中绑定的处理函数。</desc>
        </params>
      </function>
      <function name="load" return="lhgcore">
        <desc>在每一个匹配元素的load事件中绑定一个处理函数。</desc>
        <longdesc>如果绑定给window对象，则会在所有内容加载后触发，包括窗口，框架，对象和图像。如果绑定在元素上，则当元素的内容加载完毕后触发。

'''注意:'''只有当在这个元素完全加载完之前绑定load的处理函数,才会在他加载完后触发。如果之后再绑定就永远不会触发了。所以'''不要'''在$(document).ready()里绑定load事件，因为lhgcore会在所有DOM加载完成后再绑定load事件。</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的load事件中绑定的处理函数。</desc>
        </params>
      </function>
      <function name="mousedown" return="lhgcore">
        <desc>在每一个匹配元素的mousedown事件中绑定一个处理函数。</desc>
        <longdesc>mousedown事件在鼠标在元素上点击后会触发</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的mousedown事件中绑定的处理函数。</desc>
        </params>
      </function>
      <function name="mousemove" return="lhgcore">
        <desc>在每一个匹配元素的mousemove事件中绑定一个处理函数。</desc>
        <longdesc>mousemove 事件通过鼠标在元素上移动来触发。事件处理函数会被传递一个变量——事件对象，其.clientX 和 .clientY 属性代表鼠标的坐标</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的mousemove事件中绑定的处理函数。</desc>
        </params>
      </function>
      <function name="mouseout" return="lhgcore">
        <desc>在每一个匹配元素的mouseout事件中绑定一个处理函数。</desc>
        <longdesc>mouseout事件在鼠标从元素上离开后会触发</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的mouseout事件中绑定的处理函数。</desc>
        </params>
      </function>
      <function name="mouseover" return="lhgcore">
        <desc>在每一个匹配元素的mouseover事件中绑定一个处理函数。</desc>
        <longdesc>mouseover事件会在鼠标移入对象时触发</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的mouseover事件中绑定的处理函数。</desc>
        </params>
      </function>
      <function name="mouseup" return="lhgcore">
        <desc>在每一个匹配元素的mouseup事件中绑定一个处理函数。</desc>
        <longdesc>mouseup事件会在鼠标点击对象释放时</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的mouseup事件中绑定的处理函数。</desc>
        </params>
      </function>
      <function name="resize" return="lhgcore">
        <desc>在每一个匹配元素的resize事件中绑定一个处理函数。</desc>
        <longdesc>当文档窗口改变大小时触发</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的resize事件中绑定的处理函数。</desc>
        </params>
        <example>
          <desc>让人每次改变页面窗口的大小时很郁闷的方法:</desc>
          <code>$(window).resize(function(){
  alert("Stop it!");
});</code>
        </example>
      </function>
      <function name="scroll" return="lhgcore">
        <desc>在每一个匹配元素的scroll事件中绑定一个处理函数。</desc>
        <longdesc>当滚动条发生变化时触发</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的resize事件中绑定的处理函数。</desc>
        </params>
        <example>
          <desc>当页面滚动条变化时，执行的函数:</desc>
          <code>$(window).scroll( function() { /* ...do something... */ } );</code>
        </example>
      </function>
      <function name="select" return="lhgcore">
        <desc>在每一个匹配元素的select事件中绑定一个处理函数。</desc>
        <longdesc>当用户在文本框(包括input和textarea)中选中某段文本时会触发select事件。</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的select事件中绑定的处理函数。</desc>
        </params>
        <example>
          <desc>当文本框中文本被选中时执行的函数:</desc>
          <code>J("input[type=text]").select( function () { /* ...do something... */ } );</code>
        </example>
      </function>
      <function name="submit" return="lhgcore">
        <desc>在每一个匹配元素的submit事件中绑定一个处理函数。</desc>
        <longdesc>submit事件将会在表单提交时触发</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的submit事件中绑定的处理函数</desc>
        </params>
        <example>
          <desc>如果你要阻止表单提交:</desc>
          <code>J("form").submit( function () {
  return false;
} );</code>
        </example>
      </function>
      <function name="unload" return="lhgcore">
        <desc>在每一个匹配元素的unload事件中绑定一个处理函数。</desc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的unload事件中绑定的处理函数。</desc>
        </params>
        <example>
          <desc>页面卸载的时候弹出一个警告框:</desc>
          <code>J(window).unload( function () { alert("Bye now!"); } );</code>
        </example>
      </function>
    </subcat>
  </cat>
  <cat value="Ajax">
    <subcat value="Ajax 请求">
      <function name="lhgcore.ajax" return="XMLHttpRequest">
        <desc>通过远程 HTTP GET 或 POST 请求载入信息。</desc>
        <params name="url" type="String">
          <desc>待载入页面的URL地址</desc>
        </params>
        <params name="type" type="String" optional="true">
          <desc>发送请求的方式，默认为GET</desc>
        </params>
        <params name="data" type="Map" optional="true">
          <desc>待发送 Key/value 参数。</desc>
        </params>
        <params name="fn" type="Function" optional="true">
          <desc>载入成功时回调函数。</desc>
        </params>
        <params name="ret" type="String" optional="true">
          <desc>返回内容格式，xml,json, text。默认为text数据</desc>
        </params>
        <example>
          <desc>请求 test.php 网页，返回text值。</desc>
          <code>J.ajax({url:"test.php"});</code>
        </example>
        <example>
          <desc>用post方式请求 test.php 网页，传送2个参数，返回text值。</desc>
          <code>J.ajax({url:"test.php", type:"post", data:"name=John&amp;time=2pm" } );</code>
        </example>
        <example>
          <desc>显示 test.php 返回值(类型为json)。</desc>
          <code>J.ajax({url:"test.php", fn:function(data){
  alert("Data Loaded: " + data);
}, ret:"json");</code>
        </example>
      </function>
    </subcat>
  </cat>
  <cat value="工具">
    <subcat value="浏览器">
      <property name="lhgcore.support" return="Object">
        <desc><span style="color:#f00;">这个工具没加在主JS库里，而是加在了扩展的库里。</span>也就是在lhgcoreExend.js文件里。一组用于展示不同浏览器各自特性和bug的属性集合。</desc>
        <longdesc>lhgcore提供了一系列属性，你也可以自由增加你自己的属性。其中许多属性是很低级的，所以很难说他们能否在日新月异的发展中一直保持有效，但这这些主要用于插件和内核开发者。

所有这些支持的属性值都通过特性检测来实现，而不是用任何浏览器检测。以下有一些非常棒的资源用于解释这些特性检测是如何工作的：&lt;ul&gt;&lt;li&gt;http://peter.michaux.ca/articles/feature-detection-state-of-the-art-browser-scripting&lt;/li&gt;&lt;li&gt;http://yura.thinkweb2.com/cft/&lt;/li&gt;&lt;li&gt;http://www.jibbering.com/faq/faq_notes/not_browser_detect.html&lt;/li&gt;&lt;/ul&gt;lhgcore.support主要包括以下测试：

'''boxModel''': 如果这个页面和浏览器是以W3C CSS盒式模型来渲染的，则等于true。通常在IE 6和IE 7的怪癖模式中这个值是false。在document准备就绪前，这个值是null。

'''cssFloat''': 如果用cssFloat来访问CSS的float的值，则返回true。目前在IE中会返回false,他用styleFloat代替。

'''hrefNormalized''': 如果浏览器从getAttribute("href")返回的是原封不动的结果，则返回true。在IE中会返回false，因为他的URLs已经常规化了。

'''htmlSerialize''': 如果浏览器通过innerHTML插入链接元素的时候会序列化这些链接，则返回true，目前IE中返回false。

'''leadingWhitespace''': 如果在使用innerHTML的时候浏览器会保持前导空白字符，则返回true，目前在IE 6-8中返回false。

'''noCloneEvent''': 如果浏览器在克隆元素的时候不会连同事件处理函数一起复制，则返回true，目前在IE中返回false。

'''objectAll''': 如果在某个元素对象上执行getElementsByTagName("*")会返回所有子孙元素，则为true，目前在IE 7中为false。

'''opacity''': 如果浏览器能适当解释透明度样式属性，则返回true，目前在IE中返回false，因为他用alpha滤镜代替。

'''scriptEval''': 使用 appendChild/createTextNode 方法插入脚本代码时，浏览器是否执行脚步，目前在IE中返回false，IE使用 .text 方法插入脚本代码以执行。

'''style''': 如果getAttribute("style")返回元素的行内样式，则为true。目前IE中为false，因为他用cssText代替。

'''tbody''': 如果浏览器允许table元素不包含tbody元素，则返回true。目前在IE中会返回false，他会自动插入缺失的tbody。</longdesc>
        <example>
          <desc>检测浏览器是否支持盒式模型</desc>
          <code>lhgcore.support.boxModel</code>
        </example>
      </property>
      <property name="lhgcore.browser" return="Map">
        <desc>浏览器内核标识。依据 navigator.userAgent 判断。</desc>
        <longdesc>可用值:  sa ( safari ) 

 op ( opera ) 

 ie ( msie )

 i7 ( msie7+ )

 i8 ( msie8 )

 ch ( chrome ) 

 mz ( mozilla )  此属性在 DOM 树加载完成前即有效，可用于为特定浏览器设置 ready 事件。 

浏览器对象检测技术与此属性共同使用可提供可靠的浏览器检测支持。</longdesc>
        <example>
          <desc>在 Microsoft's Internet Explorer 浏览器中返回 true。</desc>
          <code>J.browser.ie</code>
        </example>
        <example>
          <desc>仅在 Safari 中提示 "this is safari!" 。</desc>
          <code>if (J.browser.safari) {
   alert("this is safari!");
}</code>
        </example>
      </property>
      <property name="lhgcore.boxModel" return="Boolean">
        <desc>当前页面中浏览器是否使用标准盒模型渲染页面。 建议使用 lhgcore.support.boxModel 代替。W3C CSS 盒模型.</desc>
        <example>
          <desc>在 Internet Explorer 怪癖模式（QuirksMode）中返回 False。</desc>
          <code>J.boxModel</code>
        </example>
      </property>
    </subcat>
    <subcat value="数组和对象操作">
      <function name="lhgcore.each" return="Object">
        <desc>通用例遍方法，可用于例遍对象和数组。</desc>
        <longdesc>不同于例遍 lhgcore 对象的 J().each() 方法，此方法可用于例遍任何对象。回调函数拥有两个参数：第一个为对象的成员或数组的索引，第二个为对应变量或内容。如果需要退出 each 循环可使回调函数返回 false，其它返回值将被忽略。</longdesc>
        <params name="object" type="Object">
          <desc>需要例遍的对象或数组。</desc>
        </params>
        <params name="callback" type="Function" optional="true">
          <desc>每个成员/元素执行的回调函数。</desc>
        </params>
        <example>
          <desc>例遍数组，同时使用元素索引和内容。</desc>
          <code>J.each( [0,1,2], function(i, n){
  alert( "Item #" + i + ": " + n );
});</code>
        </example>
        <example>
          <desc>例遍对象，同时使用成员名称和变量内容。</desc>
          <code>J.each( { name: "John", lang: "JS" }, function(i, n){
  alert( "Name: " + i + ", Value: " + n );
});</code>
        </example>
      </function>
      <function name="lhgcore.makeArray" return="Array">
        <desc>将类数组对象转换为数组对象。</desc>
        <longdesc>类数组对象有 length 属性，其成员索引为 0 至 length - 1。实际中此函数在 lhgcore 中将自动使用而无需特意转换。</longdesc>
        <params name="obj" type="Object">
          <desc>类数组对象。</desc>
        </params>
        <example>
          <desc>过滤数组中小于 0 的元素。</desc>
          <html>&lt;div&gt;First&lt;/div&gt;&lt;div&gt;Second&lt;/div&gt;&lt;div&gt;Third&lt;/div&gt;&lt;div&gt;Fourth&lt;/div&gt;</html>
          <code>var arr = lhgcore.makeArray(document.getElementsByTagName("div"));
arr.reverse(); // 使用数组翻转函数</code>
          <result>Fourth
Third
Second
First</result>
        </example>
      </function>
      <function name="lhgcore.grep" return="Array">
        <desc>使用过滤函数过滤数组元素。</desc>
        <longdesc>此函数至少传递两个参数：待过滤数组和过滤函数。过滤函数必须返回 true 以保留元素或 false 以删除元素。</longdesc>
        <params name="array" type="Array">
          <desc>待过滤数组。</desc>
        </params>
        <params name="callback" type="Function">
          <desc>此函数将处理数组每个元素。第一个参数为当前元素，第二个参数而元素索引值。此函数应返回一个布尔值。另外，此函数可设置为一个字符串，当设置为字符串时，将视为“lambda-form”（缩写形式？），其中 a 代表数组元素，i 代表元素索引值。如“a &gt; 0”代表“function(a){ return a &gt; 0; }”。</desc>
        </params>
        <params name="invert" type="Boolean" optional="true">
          <desc>如果 "invert" 为 false 或为设置，则函数返回数组中由过滤函数返回 true 的元素，当"invert" 为 true，则返回过滤函数中返回 false 的元素集。</desc>
        </params>
        <example>
          <desc>过滤数组中小于 0 的元素。</desc>
          <code>J.grep( [0,1,2], function(n,i){
  return n &gt; 0;
});</code>
          <result>[1, 2]</result>
        </example>
        <example>
          <desc>排除数组中大于 0 的元素，使用第三个参数进行排除。</desc>
          <code>J.grep( [0,1,2], function(n,i){
  return n &gt; 0;
}, true);</code>
          <result>[0]</result>
        </example>
      </function>
      <function name="lhgcore.map" return="Array">
        <desc>将一个数组中的元素转换到另一个数组中。</desc>
        <longdesc>作为参数的转换函数会为每个数组元素调用，而且会给这个转换函数传递一个表示被转换的元素作为参数。转换函数可以返回转换后的值、null（删除数组中的项目）或一个包含值的数组，并扩展至原始数组中。</longdesc>
        <params name="array" type="Array">
          <desc>待转换数组。</desc>
        </params>
        <params name="callback" type="Function">
          <desc>为每个数组元素调用，而且会给这个转换函数传递一个表示被转换的元素作为参数。函数可返回任何值。另外，此函数可设置为一个字符串，当设置为字符串时，将视为“lambda-form”（缩写形式？），其中 a 代表数组元素。如“a * a”代表“function(a){ return a * a; }”。</desc>
        </params>
        <example>
          <desc>将原数组中每个元素加 4 转换为一个新数组。</desc>
          <code>J.map( [0,1,2], function(n){
  return n + 4;
});</code>
          <result>[4, 5, 6]</result>
        </example>
        <example>
          <desc>原数组中大于 0 的元素加 1 ，否则删除。</desc>
          <code>J.map( [0,1,2], function(n){
  return n &gt; 0 ? n + 1 : null;
});</code>
          <result>[2, 3]</result>
        </example>
        <example>
          <desc>原数组中每个元素扩展为一个包含其本身和其值加 1 的数组，并转换为一个新数组。</desc>
          <code>J.map( [0,1,2], function(n){
  return [ n, n + 1 ];
});</code>
          <result>[0, 1, 1, 2, 2, 3]</result>
        </example>
      </function>
      <function name="lhgcore.inArray" return="Number">
        <desc>确定第一个参数在数组中的位置，从0开始计数(如果没有找到则返回 -1 )。</desc>
        <params name="value" type="Any">
          <desc>用于在数组中查找是否存在</desc>
        </params>
        <params name="array" type="Array">
          <desc>待处理数组。</desc>
        </params>
        <example>
          <desc>查看对应元素的位置</desc>
          <code>var arr = [ 4, "Pete", 8, "John" ];
J.inArray("John", arr);  //3
J.inArray(4, arr);  //0
J.inArray("David", arr);  //-1</code>
        </example>
      </function>
      <function name="lhgcore.merge" return="Array">
        <desc>合并两个数组</desc>
        <longdesc>返回的结果会修改第一个数组的内容——第一个数组的元素后面跟着第二个数组的元素。要去除重复项，请使用$.unique()</longdesc>
        <params name="first" type="Array">
          <desc>第一个待处理数组，会改变其中的元素。</desc>
        </params>
        <params name="second" type="Array">
          <desc>第二个待处理数组，不会改变其中的元素。</desc>
        </params>
        <example>
          <desc>合并两个数组到第一个数组上。</desc>
          <code>J.merge( [0,1,2], [2,3,4] )</code>
          <result>[0,1,2,2,3,4]</result>
        </example>
      </function>
    </subcat>
    <subcat value="测试操作">
      <function name="lhgcore.isArray" return="Boolean">
        <desc>测试对象是否为数组。</desc>
        <params name="obj" type="Object">
          <desc>用于测试是否为数组的对象</desc>
        </params>
        <example>
          <desc>检测是否为数组</desc>
          <code>J("b").append( "" + J.isArray([]) );</code>
          <result>&lt;b&gt;true&lt;/b&gt;</result>
        </example>
      </function>
      <function name="lhgcore.isFunction" return="Boolean">
        <desc>测试对象是否为函数。</desc>
        <params name="obj" type="Object">
          <desc>用于测试是否为函数的对象</desc>
        </params>
        <example>
          <desc>检测是否为函数</desc>
          <code>function stub() {
    }
var objs = [
            function () {},
            { x:15, y:20 },
            null,
            stub,
            "function"
          ];
        lhgcore.each(objs, function (i) {
        var isFunc = lhgcore.isFunction(objs[i]);
        J("span").text(isFunc);
      });</code>
          <result>[ true,false,false,true,false ]</result>
        </example>
      </function>
    </subcat>
    <subcat value="字符串操作">
      <function name="lhgcore.trim" return="String">
        <desc>去掉字符串起始和结尾的空格。</desc>
        <params name="str" type="String">
          <desc>需要处理的字符串</desc>
        </params>
        <example>
          <desc>去掉字符串起始和结尾的空格。</desc>
          <code>J.trim("  hello, how are you?  ");</code>
          <result>"hello, how are you?"</result>
        </example>
      </function>
    </subcat>
    <subcat value="URL">
      <property name="lhgcore.url['key']" return="String">
        <desc>取url地址参数的值。</desc>
        <example>
          <desc>按照key/value对来取参数的值。</desc>
          <code>
    如url为：http://www.abc.com/abc.html?id=2
    alert( J.url['id'] );
    </code>
          <result>2</result>
        </example>
      </property>
    </subcat>
  </cat>
</docs>

